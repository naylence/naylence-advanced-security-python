#!/usr/bin/env python3
"""
Integration test for generated PKI with OpenSSL verification.

This test validates that the PKI hierarchy generated by setup_pki.py
is compatible with OpenSSL verification.
"""

import subprocess
import tempfile
from pathlib import Path

import pytest

try:
    from cryptography.hazmat.primitives import serialization
    from cryptography.hazmat.primitives.asymmetric import ed25519

    from naylence.fame.security.cert.ca_service import CASigningService

    CRYPTO_AVAILABLE = True
except ImportError:
    CRYPTO_AVAILABLE = False


def run_openssl_command(cmd):
    """Run an OpenSSL command and return success, stdout, stderr."""
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
        return result.returncode == 0, result.stdout, result.stderr
    except Exception as e:
        return False, "", str(e)


@pytest.mark.skipif(not CRYPTO_AVAILABLE, reason="Cryptography not available")
class TestGeneratedPKI:
    """Test generated PKI infrastructure with OpenSSL."""

    @pytest.fixture
    def pki_directory(self):
        """Find or create PKI directory for testing."""
        pki_dir = Path("test-pki-openssl")
        if not pki_dir.exists():
            pytest.skip(
                f"PKI directory {pki_dir} not found. "
                f"Run: python setup_pki.py --output test-pki-openssl --openssl-compatible"
            )
        return pki_dir

    @pytest.fixture
    def pki_files(self, pki_directory):
        """Load PKI files."""
        root_cert_file = pki_directory / "root-ca.crt"
        intermediate_cert_file = pki_directory / "intermediate-ca.crt"
        intermediate_key_file = pki_directory / "intermediate-ca.key"

        required_files = [root_cert_file, intermediate_cert_file, intermediate_key_file]

        for file in required_files:
            if not file.exists():
                pytest.skip(f"Required PKI file {file} not found")

        return {
            "root_cert": root_cert_file,
            "intermediate_cert": intermediate_cert_file,
            "intermediate_key": intermediate_key_file,
        }

    def test_pki_files_exist(self, pki_files):
        """Test that all required PKI files exist."""
        for name, file_path in pki_files.items():
            assert file_path.exists(), f"PKI file {name} should exist at {file_path}"
            assert file_path.stat().st_size > 0, f"PKI file {name} should not be empty"

    def test_ca_service_initialization(self, pki_files):
        """Test that CA service can be initialized with generated PKI."""
        intermediate_cert_pem = pki_files["intermediate_cert"].read_text()
        intermediate_key_pem = pki_files["intermediate_key"].read_text()

        # Should not raise an exception
        ca_service = CASigningService(intermediate_cert_pem, intermediate_key_pem)
        assert ca_service is not None

    def test_certificate_generation_and_openssl_verification(self, pki_files):
        """Test that generated certificates can be verified with OpenSSL."""
        # Load CA service
        intermediate_cert_pem = pki_files["intermediate_cert"].read_text()
        intermediate_key_pem = pki_files["intermediate_key"].read_text()

        ca_service = CASigningService(intermediate_cert_pem, intermediate_key_pem)

        # Generate a test key and certificate
        node_key = ed25519.Ed25519PrivateKey.generate()
        node_pub_pem = (
            node_key.public_key()
            .public_bytes(
                encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            .decode()
        )

        test_cert_pem = ca_service.sign_node_cert(
            public_key_pem=node_pub_pem,
            node_id="test-openssl-node",
            node_sid="test-openssl-sid",
            physical_path="/production/datacenter1/node001",
            logicals=["/production/api/v1", "/production/workers/queue1"],
        )

        # Verify with OpenSSL
        with tempfile.TemporaryDirectory() as temp_dir:
            test_cert_file = Path(temp_dir) / "test-cert.crt"
            test_cert_file.write_text(test_cert_pem)

            cmd = [
                "openssl",
                "verify",
                "-CAfile",
                str(pki_files["root_cert"]),
                "-untrusted",
                str(pki_files["intermediate_cert"]),
                str(test_cert_file),
            ]

            success, stdout, stderr = run_openssl_command(cmd)

            assert success, f"OpenSSL verification failed. STDOUT: {stdout}, STDERR: {stderr}"
            assert "OK" in stdout, f"Expected 'OK' in verification output, got: {stdout}"

    def test_certificate_contains_subject_alternative_names(self, pki_files):
        """Test that generated certificates contain Subject Alternative Names."""
        # Load CA service
        intermediate_cert_pem = pki_files["intermediate_cert"].read_text()
        intermediate_key_pem = pki_files["intermediate_key"].read_text()

        ca_service = CASigningService(intermediate_cert_pem, intermediate_key_pem)

        # Generate a test certificate
        node_key = ed25519.Ed25519PrivateKey.generate()
        node_pub_pem = (
            node_key.public_key()
            .public_bytes(
                encoding=serialization.Encoding.PEM, format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            .decode()
        )

        test_cert_pem = ca_service.sign_node_cert(
            public_key_pem=node_pub_pem,
            node_id="test-san-node",
            node_sid="test-san-sid",
            physical_path="/test/path",
            logicals=["/test/api", "/test/service"],
        )

        # Check certificate details with OpenSSL
        with tempfile.TemporaryDirectory() as temp_dir:
            test_cert_file = Path(temp_dir) / "test-cert.crt"
            test_cert_file.write_text(test_cert_pem)

            cmd = ["openssl", "x509", "-in", str(test_cert_file), "-text", "-noout"]

            success, stdout, stderr = run_openssl_command(cmd)

            assert success, f"OpenSSL text extraction failed. STDERR: {stderr}"
            assert "Subject Alternative Name:" in stdout, (
                "Certificate should contain Subject Alternative Name extension"
            )

    @pytest.mark.skipif(
        subprocess.run(["which", "openssl"], capture_output=True).returncode != 0,
        reason="OpenSSL not available",
    )
    def test_openssl_available(self):
        """Test that OpenSSL is available for testing."""
        success, stdout, stderr = run_openssl_command(["openssl", "version"])
        assert success, f"OpenSSL should be available. STDERR: {stderr}"
        assert "OpenSSL" in stdout, f"Expected OpenSSL version output, got: {stdout}"

    def test_certificate_chain_validation(self, pki_files):
        """Test that the certificate chain validates correctly."""
        with tempfile.TemporaryDirectory() as temp_dir:
            # Create a certificate chain file
            chain_file = Path(temp_dir) / "chain.pem"

            # Combine intermediate and root certificates
            intermediate_pem = pki_files["intermediate_cert"].read_text()
            root_pem = pki_files["root_cert"].read_text()

            chain_file.write_text(intermediate_pem + "\n" + root_pem)

            # Verify the intermediate certificate against the root
            cmd = [
                "openssl",
                "verify",
                "-CAfile",
                str(pki_files["root_cert"]),
                str(pki_files["intermediate_cert"]),
            ]

            success, stdout, stderr = run_openssl_command(cmd)

            assert success, (
                f"Intermediate certificate verification failed. STDOUT: {stdout}, STDERR: {stderr}"
            )
            assert "OK" in stdout, f"Expected 'OK' in verification output, got: {stdout}"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
